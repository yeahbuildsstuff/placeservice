<!DOCTYPE html>
<link rel="icon" type="image/x-icon" href="https://raw.githubusercontent.com/yeahbuildsstuff/GameAssetServiceRepo/main/appicon.ico">
<html>
<head>
  <meta charset="UTF-8">
  <title>Game</title>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>

  <style>
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      overflow: hidden;
      cursor: url("https://raw.githubusercontent.com/yeahbuildsstuff/GameAssetServiceRepo/main/cursor.cur"), auto;
    }

    #renderCanvas {
      width: 100%;
      height: 100%;
      display: block;
      cursor: url("https://raw.githubusercontent.com/yeahbuildsstuff/GameAssetServiceRepo/main/cursor.cur"), auto;
    }

    .uiBtn {
      background: rgba(165,165,165,0.4);
      border: none;
      font-family: "Arimo", sans-serif;
      font-style: italic;
      font-weight: bold;
      color: rgb(255,255,255);
      cursor: pointer;
      font-size: 14px;
      -webkit-text-stroke: 1px black;
      text-shadow: 0 0 1px black;
      padding: 0;
      height: 25px;
      width: 100px;
    }

    .btnText {
      display: inline-block;
      padding: 2px 6px;
    }
  </style>
</head>
<body>

<canvas id="renderCanvas"></canvas>

<div id="topButtons" style="
  position: absolute;
  top: 0px;
  left: 0px;
  display: flex;
  gap: 0px;
  z-index: 20;
">
  <div style="width:100px"></div>

  <button id="helpBtn" class="uiBtn"><span class="btnText">Help</span></button>
  <button id="fullscreenBtn" class="uiBtn"><span class="btnText">Fullscreen</span></button>
  <button id="exitBtn" class="uiBtn"><span class="btnText">Exit</span></button>
</div>

<div id="helpPopup" style="
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 420px;
  max-height: 70%;
  overflow-y: auto;
  background: #fff8c6;
  border: 1px solid black;
  padding: 20px;
  display: none;
  z-index: 30;
"></div>

<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);

document.getElementById("fullscreenBtn").onclick = () => {
  if (!document.fullscreenElement) {
    document.documentElement.requestFullscreen();
  } else {
    document.exitFullscreen();
  }
};

document.getElementById("exitBtn").onclick = () => {
  window.close();
};

async function loadHelpFile(url) {
  const text = await fetch(url).then(r => r.text());
  return parseHelpFormat(text);
}

function parseHelpFormat(raw) {
  const lines = raw.split("\n");
  const html = [];

  for (let line of lines) {
    line = line.trim();
    if (!line) continue;

    if (line.startsWith("<line.empty>")) {
      html.push("<div style='height:10px'></div>");
      continue;
    }

    if (line.startsWith("<line.new>")) {
      const match = line.match(/<line\.new>\s*"([^"]+)",([^,]+),([^,]+),(.+)/);

      if (match) {
        const text = match[1];
        const weight = match[2];
        const size = match[3];
        const font = match[4];

        html.push(`
          <div style="
            font-family:${font};
            font-size:${size}px;
            font-weight:${weight === 'Bold' ? 'bold' : 'normal'};
            margin-bottom:6px;
          ">
            ${text}
          </div>
        `);
      }
    }
  }

  return html.join("");
}

function showHelpPopup(html) {
  const popup = document.getElementById("helpPopup");
  popup.innerHTML = html;
  popup.style.display = "block";
}

function hideHelpPopup() {
  document.getElementById("helpPopup").style.display = "none";
}

document.addEventListener("keydown", e => {
  if (e.key === "Escape") hideHelpPopup();
});

document.getElementById("helpBtn").onclick = async () => {
  const html = await loadHelpFile(
    "https://raw.githubusercontent.com/yeahbuildsstuff/GameAssetServiceRepo/main/text_files/Controls.help"
  );
  showHelpPopup(html);
};

const world = new CANNON.World();
world.gravity.set(0, -157.12, 0);
world.broadphase = new CANNON.NaiveBroadphase();
world.solver.iterations = 10;

const groundMatPhys = new CANNON.Material("groundMatPhys");
const playerMatPhys = new CANNON.Material("playerMatPhys");
world.addContactMaterial(new CANNON.ContactMaterial(
  groundMatPhys,
  playerMatPhys,
  { friction: 1.0, restitution: 0.0 }
));


// ============================================================
// PLACE_CODE — ROOM (2× SIZE, MATTE, FIXED WINDOW, COLLISION)
// ============================================================

function PLACE_CODE(scene) {

 
  const floorcolor = new BABYLON.Color3(0.6,0.8,0.5);

  const roomWidth = 160;
  const roomDepth = 160;
  const roomHeight = 60;
  const wallThickness = 1;

  // FLOOR (collision)
  let floor = BABYLON.MeshBuilder.CreateBox("floor", {
    width: roomWidth,
    depth: roomDepth,
    height: 1
  }, scene);
  floor.position = new BABYLON.Vector3(0, -0.4, 0);

  let floorMat = new BABYLON.StandardMaterial("floorMat", scene);
  floorMat.diffuseColor = floorcolor;
  floorMat.specularColor = new BABYLON.Color3(0,0,0);
  floor.material = floorMat;

  let floorBody = new CANNON.Body({ mass: 0, material: groundMatPhys });
  floorBody.addShape(new CANNON.Box(new CANNON.Vec3(roomWidth/2, 0.4, roomDepth/2)));
  floorBody.position.set(0, -0.4, 0);
  world.addBody(floorBody);
}

function createScene() {
  const scene = new BABYLON.Scene(engine);

  scene.clearColor = new BABYLON.Color3(1, 1, 1);

  const skybox = BABYLON.MeshBuilder.CreateBox("skyBox", { size: 2000 }, scene);
  const skyboxMaterial = new BABYLON.StandardMaterial("skyBoxMat", scene);

  skyboxMaterial.backFaceCulling = false;
  skyboxMaterial.disableLighting = true;

  skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture(
    "https://raw.githubusercontent.com/yeahbuildsstuff/GameAssetServiceRepo/main/null_plainsky512/null_plainsky512",
    scene,
    ["_rt.jpg","_up.jpg","_ft.jpg","_lf.jpg","_dn.jpg","_bk.jpg"]
  );

  skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
  skybox.material = skyboxMaterial;
  skybox.infiniteDistance = true;

  const spriteManagerSun = new BABYLON.SpriteManager(
    "sunManager",
    "https://raw.githubusercontent.com/yeahbuildsstuff/GameAssetServiceRepo/main/sun.png",
    1,
    { width: 512, height: 512 },
    scene
  );

  spriteManagerSun.renderingGroupId = 0;

  const sunSprite = new BABYLON.Sprite("sun", spriteManagerSun);
  sunSprite.size = 160;
  sunSprite.position = new BABYLON.Vector3(200, 100, 200);
  sunSprite.isPickable = false;
  sunSprite.renderingGroupId = 0;

  const sun = new BABYLON.DirectionalLight("sun", new BABYLON.Vector3(-1, -1, -1), scene);
  sun.position = new BABYLON.Vector3(10, 10, -10);
  sun.intensity = 0.52;

  const ambient = new BABYLON.HemisphericLight("ambient", new BABYLON.Vector3(0, 1, 0), scene);
  ambient.diffuse = new BABYLON.Color3(210/255, 210/255, 210/255);
  ambient.specular = new BABYLON.Color3(0, 0, 0);
  ambient.groundColor = new BABYLON.Color3(210/255, 210/255, 210/255);
  ambient.intensity = 0.6;

  // RUN YOUR CUSTOM ROOM CODE
  PLACE_CODE(scene);

  const rig = new BABYLON.TransformNode("rig", scene);
  rig.position.y = 5;

  const model = new BABYLON.TransformNode("model", scene);
  model.parent = rig;

  let id = 0;
  function part(name, w, h, d, y, x = 0, color) {
    const p = BABYLON.MeshBuilder.CreateBox(name + "_" + (id++), {
      width: w, height: h, depth: d
    }, scene);
    p.position.y = y;
    p.position.x = x;

    const mat = new BABYLON.StandardMaterial(name + "_mat", scene);
    mat.diffuseColor = color;
    mat.specularColor = new BABYLON.Color3(0, 0, 0);
    p.material = mat;

    p.parent = model;
    return p;
  }

  const brightYellow      = new BABYLON.Color3(245/255, 205/255, 48/255);
  const pastelBlue        = new BABYLON.Color3(128/255, 187/255, 219/255);
  const brightYellowGreen = new BABYLON.Color3(164/255, 189/255, 71/255);

  part("torso", 2, 2, 1, 2, 0, pastelBlue);
  part("leftArm", 1, 2, 1, 2, -1.5, brightYellow);
  part("rightArm", 1, 2, 1, 2, 1.5, brightYellow);
  part("leftLeg", 1, 2, 1, 0, -0.5, brightYellowGreen);
  part("rightLeg", 1, 2, 1, 0, 0.5, brightYellowGreen);

  BABYLON.SceneLoader.ImportMesh(
    "",
    "https://raw.githubusercontent.com/yeahbuildsstuff/GameAssetServiceRepo/main/",
    "head.obj",
    scene,
    function(meshes) {
      const headInner = meshes[0];
      headInner.scaling = new BABYLON.Vector3(1, 1, 1);
      headInner.rotation = new BABYLON.Vector3(0, Math.PI, 0);
      headInner.position = new BABYLON.Vector3(0, 3.5, 0);
      headInner.parent = model;

      const innerMat = new BABYLON.StandardMaterial("innerMat", scene);
      innerMat.diffuseColor = brightYellow;
      innerMat.specularColor = new BABYLON.Color3(0, 0, 0);
      headInner.material = innerMat;

      const headOuter = headInner.clone("headOuter");
      headOuter.parent = model;
      headOuter.scaling = new BABYLON.Vector3(1.002, 1.002, 1.002);

      const faceMat = new BABYLON.StandardMaterial("faceMat", scene);
      const faceTex = new BABYLON.Texture(
        "https://raw.githubusercontent.com/yeahbuildsstuff/GameAssetServiceRepo/main/defaultface.png",
        scene
      );

      faceTex.hasAlpha = true;
      faceMat.diffuseTexture = faceTex;
      faceMat.opacityTexture = faceTex;
      faceMat.emissiveColor = new BABYLON.Color3(1, 1, 1);
      faceMat.specularColor = new BABYLON.Color3(0, 0, 0);
      faceMat.backFaceCulling = false;

      headOuter.material = faceMat;
    }
  );

  const capsuleRadius = 0.6;
  const capsuleHeight = 8.0;
  const capsuleOffset = 1.0;
  const cylHeight = capsuleHeight - 2 * capsuleRadius;

  const sphereTop = new CANNON.Sphere(capsuleRadius);
  const sphereBottom = new CANNON.Sphere(capsuleRadius);
  const cylinder = new CANNON.Cylinder(capsuleRadius, capsuleRadius, cylHeight, 8);

  const playerBody = new CANNON.Body({
    mass: 1,
    material: playerMatPhys,
    linearDamping: 0.9,
    angularDamping: 1.0
  });

  playerBody.addShape(sphereTop, new CANNON.Vec3(0, cylHeight / 2, 0));
  playerBody.addShape(sphereBottom, new CANNON.Vec3(0, -cylHeight / 2, 0));

  const q = new CANNON.Quaternion();
  q.setFromEuler(Math.PI / 2, 0, 0);
  playerBody.addShape(cylinder, new CANNON.Vec3(0, 0, 0), q);

  playerBody.position.set(
    rig.position.x,
    rig.position.y + capsuleHeight / 2 + capsuleOffset,
    rig.position.z
  );
  playerBody.fixedRotation = true;
  playerBody.updateMassProperties();
  world.addBody(playerBody);

  let camYaw = Math.PI / 2;
  let camPitch = Math.PI / 4;
  let camDistance = 15 / 1.4;

  const camera = new BABYLON.FreeCamera("cam", new BABYLON.Vector3(0, 5, -10), scene);
  camera.minZ = 0.1;

  let isMouseDown = false;
  canvas.addEventListener("pointerdown", () => isMouseDown = true);
  canvas.addEventListener("pointerup", () => isMouseDown = false);

  canvas.addEventListener("pointermove", (e) => {
    if (!isMouseDown) return;
    camYaw += e.movementX * 0.005;
    camPitch += e.movementY * 0.005;
  });

  const input = { forward: 0, right: 0 };

  window.addEventListener("keydown", (e) => {
    if (e.key === "w") input.forward = -1;
    if (e.key === "s") input.forward = 1;
    if (e.key === "a") input.right = 1;
    if (e.key === "d") input.right = -1;
  });

  window.addEventListener("keyup", (e) => {
    if (e.key === "w" || e.key === "s") input.forward = 0;
    if (e.key === "a" || e.key === "d") input.right = 0;
  });

  const walkSpeed = 0.24;

  let camPos = camera.position.clone();
  let camTarget = new BABYLON.Vector3();
  const followTime = 0.125;

  scene.onBeforeRenderObservable.add(() => {
    const dt = engine.getDeltaTime() / 1000;
    const fixedTimeStep = 1 / 60;

    const forward = new BABYLON.Vector3(Math.sin(camYaw), 0, Math.cos(camYaw));
    const right = new BABYLON.Vector3(Math.sin(camYaw + Math.PI / 2), 0, Math.cos(camYaw + Math.PI / 2));

    let move = forward.scale(input.forward).add(right.scale(input.right));

    if (move.length() > 0.01) {
      move.normalize();
      rig.position.addInPlace(move.scale(walkSpeed));

      const targetAngle = Math.atan2(move.x, move.z);
      model.rotation.y = BABYLON.Scalar.Lerp(model.rotation.y, targetAngle, 0.15);
    }

    playerBody.position.x = rig.position.x;
    playerBody.position.z = rig.position.z;

    world.step(fixedTimeStep, dt, 3);

    rig.position.x = playerBody.position.x;
    rig.position.y = playerBody.position.y - capsuleHeight / 2 + 1;
    rig.position.z = playerBody.position.z;

    const headPos = new BABYLON.Vector3(
      rig.position.x,
      rig.position.y + 3.5,
      rig.position.z
    );

    const desiredCamPos = new BABYLON.Vector3(
      headPos.x + Math.sin(camYaw) * Math.cos(camPitch) * camDistance,
      headPos.y + Math.sin(camPitch) * camDistance,
      headPos.z + Math.cos(camYaw) * Math.cos(camPitch) * camDistance
    );

    camPos = BABYLON.Vector3.Lerp(camPos, desiredCamPos, dt / followTime);
    camera.position.copyFrom(camPos);

    camTarget = BABYLON.Vector3.Lerp(camTarget, headPos, dt / followTime);
    camera.setTarget(camTarget);
  });

  return scene;
}

const scene = createScene();
engine.runRenderLoop(() => scene.render());
window.addEventListener("resize", () => engine.resize());
</script>

</body>
</html>

