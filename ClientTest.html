<!DOCTYPE html>
<link rel="icon" type="image/x-icon" href="https://raw.githubusercontent.com/yeahbuildsstuff/GameAssetServiceRepo/main/appicon.ico">
<html>
<head>
  <meta charset="UTF-8">
  <title>Game</title>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>

  <style>
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      overflow: hidden;
      cursor: url("https://raw.githubusercontent.com/yeahbuildsstuff/GameAssetServiceRepo/main/cursor.cur"), auto;
    }

    #renderCanvas {
      width: 100%;
      height: 100%;
      display: block;
      cursor: url("https://raw.githubusercontent.com/yeahbuildsstuff/GameAssetServiceRepo/main/cursor.cur"), auto;
    }

    .uiBtn {
      background: rgba(165,165,165,0.4);
      border: none;
      font-family: "Arimo", sans-serif;
      font-style: italic;
      font-weight: bold;
      color: rgb(255,255,255);
      cursor: pointer;
      font-size: 14px;
      -webkit-text-stroke: 1px black;
      text-shadow: 0 0 1px black;
      padding: 0;
      height: 25px;
      width: 100px;
    }

    .btnText {
      display: inline-block;
      padding: 2px 6px;
    }
  </style>
</head>
<body>

<canvas id="renderCanvas"></canvas>

<div id="topButtons" style="
  position: absolute;
  top: 0px;
  left: 0px;
  display: flex;
  gap: 0px;
  z-index: 20;
">
  <div style="width:100px"></div>

  <button id="helpBtn" class="uiBtn"><span class="btnText">Help</span></button>
  <button id="fullscreenBtn" class="uiBtn"><span class="btnText">Fullscreen</span></button>
  <button id="exitBtn" class="uiBtn"><span class="btnText">Exit</span></button>
</div>

<div id="helpPopup" style="
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 420px;
  max-height: 70%;
  overflow-y: auto;
  background: #fff8c6;
  border: 1px solid black;
  padding: 20px;
  display: none;
  z-index: 30;
"></div>

<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);
// Force-create audio engine if Babylon didn't
if (!BABYLON.Engine.audioEngine) {
  BABYLON.Engine.audioEngine = new BABYLON.AudioEngine();
  console.log("AudioEngine manually created");
}

window.addEventListener("pointerdown", () => {
  const ctx = BABYLON.Engine.audioEngine?.audioContext;
  if (ctx && ctx.state !== "running") {
    ctx.resume().then(() => console.log("Audio context resumed"));
  }
});


// Unlock audio on first click
window.addEventListener("pointerdown", () => {
  if (BABYLON.Engine.audioEngine) {
    BABYLON.Engine.audioEngine.unlock();
  }
}, { once: true });

async function loadHelpFile(url) {
  const text = await fetch(url).then(r => r.text());
  return parseHelpFormat(text);
}

function parseHelpFormat(raw) {
  const lines = raw.split("\n");
  const html = [];

  for (let line of lines) {
    line = line.trim();
    if (!line) continue;

    if (line.startsWith("<line.empty>")) {
      html.push("<div style='height:10px'></div>");
      continue;
    }

    if (line.startsWith("<line.new>")) {
      const match = line.match(/<line\.new>\s*"([^"]+)",([^,]+),([^,]+),(.+)/);

      if (match) {
        const text = match[1];
        const weight = match[2];
        const size = match[3];
        const font = match[4];

        html.push(`
          <div style="
            font-family:${font};
            font-size:${size}px;
            font-weight:${weight === 'Bold' ? 'bold' : 'normal'};
            margin-bottom:6px;
          ">
            ${text}
          </div>
        `);
      }
    }
  }

  return html.join("");
}

function showHelpPopup(html) {
  const popup = document.getElementById("helpPopup");
  popup.innerHTML = html;
  popup.style.display = "block";
}

function hideHelpPopup() {
  const popup = document.getElementById("helpPopup");
  popup.style.display = "none";
}

// ============================================================
// PHYSICS WORLD
// ============================================================

const world = new CANNON.World();
world.gravity.set(0, -157.12, 0);
world.broadphase = new CANNON.NaiveBroadphase();
world.solver.iterations = 10;

const groundMatPhys = new CANNON.Material("groundMatPhys");
const playerMatPhys = new CANNON.Material("playerMatPhys");
world.addContactMaterial(new CANNON.ContactMaterial(
  groundMatPhys,
  playerMatPhys,
  { friction: 1.0, restitution: 0.0 }
));

// ============================================================
// PLACE_CODE — ROOM + TEST BRICK
// ============================================================

function PLACE_CODE(scene) {

  const floorcolor = new BABYLON.Color3(0.6,0.8,0.5);

  const roomWidth = 160;
  const roomDepth = 160;
  const roomHeight = 60;

  let floor = BABYLON.MeshBuilder.CreateBox("floor", {
    width: roomWidth,
    depth: roomDepth,
    height: 1
  }, scene);
  floor.position = new BABYLON.Vector3(0, -0.4, 0);

  let floorMat = new BABYLON.StandardMaterial("floorMat", scene);
  floorMat.diffuseColor = floorcolor;
  floorMat.specularColor = new BABYLON.Color3(0,0,0);
  floor.material = floorMat;

  let floorBody = new CANNON.Body({ mass: 0, material: groundMatPhys });
  floorBody.addShape(new CANNON.Box(new CANNON.Vec3(roomWidth/2, 0.4, roomDepth/2)));
  floorBody.position.set(0, -0.4, 0);
  world.addBody(floorBody);

  // ⭐ Test brick
  const testBrick = BABYLON.MeshBuilder.CreateBox("testBrick", {
    width: 2,
    height: 1,
    depth: 2
  }, scene);

  testBrick.position = new BABYLON.Vector3(0, 0.5, 0);

  const testMat = new BABYLON.StandardMaterial("testMat", scene);
  testMat.diffuseColor = new BABYLON.Color3(0.7, 0.7, 0.7);
  testMat.specularColor = new BABYLON.Color3(0, 0, 0);
  testBrick.material = testMat;

  testBrick.draggable = true;
}

// ============================================================
// CREATE SCENE
// ============================================================

function createScene() {
  const scene = new BABYLON.Scene(engine);

  scene.clearColor = new BABYLON.Color3(1, 1, 1);

  const skybox = BABYLON.MeshBuilder.CreateBox("skyBox", { size: 2000 }, scene);
  const skyboxMaterial = new BABYLON.StandardMaterial("skyBoxMat", scene);

  skyboxMaterial.backFaceCulling = false;
  skyboxMaterial.disableLighting = true;

  skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture(
    "https://raw.githubusercontent.com/yeahbuildsstuff/GameAssetServiceRepo/main/null_plainsky512/null_plainsky512",
    scene,
    ["_rt.jpg","_up.jpg","_ft.jpg","_lf.jpg","_dn.jpg","_bk.jpg"]
  );

  skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
  skybox.material = skyboxMaterial;
  skybox.infiniteDistance = true;

  const spriteManagerSun = new BABYLON.SpriteManager(
    "sunManager",
    "https://raw.githubusercontent.com/yeahbuildsstuff/GameAssetServiceRepo/main/sun.png",
    1,
    { width: 512, height: 512 },
    scene
  );

  spriteManagerSun.renderingGroupId = 0;

  const sunSprite = new BABYLON.Sprite("sun", spriteManagerSun);
  sunSprite.size = 160;
  sunSprite.position = new BABYLON.Vector3(200, 100, 200);
  sunSprite.isPickable = false;
  sunSprite.renderingGroupId = 0;

  const sun = new BABYLON.DirectionalLight("sun", new BABYLON.Vector3(-1, -1, -1), scene);
  sun.position = new BABYLON.Vector3(10, 10, -10);
  sun.intensity = 0.52;

  const ambient = new BABYLON.HemisphericLight("ambient", new BABYLON.Vector3(0, 1, 0), scene);
  ambient.diffuse = new BABYLON.Color3(210/255, 210/255, 210/255);
  ambient.specular = new BABYLON.Color3(0, 0, 0);
  ambient.groundColor = new BABYLON.Color3(210/255, 210/255, 210/255);
  ambient.intensity = 0.6;

  PLACE_CODE(scene);

  const rig = new BABYLON.TransformNode("rig", scene);
  rig.position.y = 5;

  const model = new BABYLON.TransformNode("model", scene);
  model.parent = rig;

  let id = 0;
  function part(name, w, h, d, y, x = 0, color) {
    const p = BABYLON.MeshBuilder.CreateBox(name + "_" + (id++), {
      width: w, height: h, depth: d
    }, scene);
    p.position.y = y;
    p.position.x = x;

    const mat = new BABYLON.StandardMaterial(name + "_mat", scene);
    mat.diffuseColor = color;
    mat.specularColor = new BABYLON.Color3(0, 0, 0);
    p.material = mat;

    p.parent = model;
    p.draggable = false;
    return p;
  }

  const brightYellow      = new BABYLON.Color3(245/255, 205/255, 48/255);
  const pastelBlue        = new BABYLON.Color3(128/255, 187/255, 219/255);
  const brightYellowGreen = new BABYLON.Color3(164/255, 189/255, 71/255);

  part("torso", 2, 2, 1, 2, 0, pastelBlue);
  part("leftArm", 1, 2, 1, 2, -1.5, brightYellow);
  part("rightArm", 1, 2, 1, 2, 1.5, brightYellow);
  part("leftLeg", 1, 2, 1, 0, -0.5, brightYellowGreen);
  part("rightLeg", 1, 2, 1, 0, 0.5, brightYellowGreen);

  BABYLON.SceneLoader.ImportMesh(
    "",
    "https://raw.githubusercontent.com/yeahbuildsstuff/GameAssetServiceRepo/main/",
    "head.obj",
    scene,
    function(meshes) {
      const headInner = meshes[0];
      headInner.scaling = new BABYLON.Vector3(1, 1, 1);
      headInner.rotation = new BABYLON.Vector3(0, Math.PI, 0);
      headInner.position = new BABYLON.Vector3(0, 3.5, 0);
      headInner.parent = model;

      const innerMat = new BABYLON.StandardMaterial("innerMat", scene);
      innerMat.diffuseColor = brightYellow;
      innerMat.specularColor = new BABYLON.Color3(0, 0, 0);
      headInner.material = innerMat;

      const headOuter = headInner.clone("headOuter");
      headOuter.parent = model;
      headOuter.scaling = new BABYLON.Vector3(1.002, 1.002, 1.002);

      const faceMat = new BABYLON.StandardMaterial("faceMat", scene);
      const faceTex = new BABYLON.Texture(
        "https://raw.githubusercontent.com/yeahbuildsstuff/GameAssetServiceRepo/main/defaultface.png",
        scene
      );

      faceTex.hasAlpha = true;
      faceMat.diffuseTexture = faceTex;
      faceMat.opacityTexture = faceTex;
      faceMat.emissiveColor = new BABYLON.Color3(1, 1, 1);
      faceMat.specularColor = new BABYLON.Color3(0, 0, 0);
      faceMat.backFaceCulling = false;

      headOuter.material = faceMat;
    }
  );
  /* ============================================================
     SOUND SYSTEM (2D NON‑SPATIAL AUDIO)
     ============================================================ */

  const sounds = {};

  function loadSound(name, url, options = {}) {
    console.log("Loading sound:", name, url);

    sounds[name] = new BABYLON.Sound(
      name,
      url,
      scene,
      () => console.log("Loaded:", name),
      {
        volume: options.volume ?? 1.0,
        loop: options.loop ?? false,
        autoplay: false,
        spatialSound: false   // <‑‑ FORCE 2D SOUND
      }
    );
  }

  // LOAD CLASSIC ROBLOX SOUNDS
  loadSound("footsteps", "https://raw.githubusercontent.com/yeahbuildsstuff/PlaceService/main/sounds/footsteps.mp3", { loop: true, volume: 0.6 });
  loadSound("slingshot", "https://raw.githubusercontent.com/yeahbuildsstuff/PlaceService/main/sounds/Rubber%20band%20sling%20shot.wav");
  loadSound("tool_ping", "https://raw.githubusercontent.com/yeahbuildsstuff/PlaceService/main/sounds/electronicpingshort.wav");
  loadSound("explosion", "https://raw.githubusercontent.com/yeahbuildsstuff/PlaceService/main/sounds/Shoulder%20fired%20rocket.wav");
  loadSound("ouch", "https://raw.githubusercontent.com/yeahbuildsstuff/PlaceService/main/sounds/Kid%20saying%20Ouch.wav");
  loadSound("snap", "https://raw.githubusercontent.com/yeahbuildsstuff/PlaceService/main/sounds/snap.wav");
  loadSound("bomb_tick", "https://raw.githubusercontent.com/yeahbuildsstuff/PlaceService/main/sounds/clickfast.wav", { loop: true, volume: 0.4 });
  loadSound("ui_click", "https://raw.githubusercontent.com/yeahbuildsstuff/PlaceService/main/sounds/SWITCH3.wav");

  /* ============================================================
     UI BUTTONS (NOW THAT SOUNDS EXIST)
     ============================================================ */

  document.getElementById("helpBtn").onclick = async () => {
    if (sounds.ui_click) sounds.ui_click.play();
    const html = await loadHelpFile(
      "https://raw.githubusercontent.com/yeahbuildsstuff/GameAssetServiceRepo/main/text_files/Controls.help"
    );
    showHelpPopup(html);
  };

  document.getElementById("fullscreenBtn").onclick = () => {
    if (sounds.ui_click) sounds.ui_click.play();
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen();
    } else {
      document.exitFullscreen();
    }
  };

  document.getElementById("exitBtn").onclick = () => {
    if (sounds.ui_click) sounds.ui_click.play();
    window.location.href = "https://yeahbuildsstuff.github.io/gamemenuservice/";
  };

  document.addEventListener("keydown", e => {
    if (e.key === "Escape") {
      if (sounds.ui_click) sounds.ui_click.play();
      hideHelpPopup();
    }
  });

  /* ============================================================
     PLAYER PHYSICS BODY
     ============================================================ */

  const capsuleRadius = 0.6;
  const capsuleHeight = 8.0;
  const capsuleOffset = 1.0;
  const cylHeight = capsuleHeight - 2 * capsuleRadius;

  const sphereTop = new CANNON.Sphere(capsuleRadius);
  const sphereBottom = new CANNON.Sphere(capsuleRadius);
  const cylinder = new CANNON.Cylinder(capsuleRadius, capsuleRadius, cylHeight, 8);

  const playerBody = new CANNON.Body({
    mass: 1,
    material: playerMatPhys,
    linearDamping: 0.9,
    angularDamping: 1.0
  });

  playerBody.addShape(sphereTop, new CANNON.Vec3(0, cylHeight / 2, 0));
  playerBody.addShape(sphereBottom, new CANNON.Vec3(0, -cylHeight / 2, 0));

  const q = new CANNON.Quaternion();
  q.setFromEuler(Math.PI / 2, 0, 0);
  playerBody.addShape(cylinder, new CANNON.Vec3(0, 0, 0), q);

  playerBody.position.set(
    rig.position.x,
    rig.position.y + capsuleHeight / 2 + capsuleOffset,
    rig.position.z
  );
  playerBody.fixedRotation = true;
  playerBody.updateMassProperties();
  world.addBody(playerBody);

  /* ============================================================
     CAMERA + INPUT
     ============================================================ */

  let camYaw = Math.PI / 2;
  let camPitch = Math.PI / 4;
  let camDistance = 15 / 1.4;

  const camera = new BABYLON.FreeCamera("cam", new BABYLON.Vector3(0, 5, -10), scene);
  camera.minZ = 0.1;

  let isMouseDown = false;
  canvas.addEventListener("pointerdown", () => isMouseDown = true);
  canvas.addEventListener("pointerup", () => isMouseDown = false);

  canvas.addEventListener("pointermove", (e) => {
    if (!isMouseDown) return;
    camYaw += e.movementX * 0.005;
    camPitch += e.movementY * 0.005;
  });

  const input = { forward: 0, right: 0 };

  window.addEventListener("keydown", (e) => {
    if (e.key === "w") input.forward = -1;
    if (e.key === "s") input.forward = 1;
    if (e.key === "a") input.right = 1;
    if (e.key === "d") input.right = -1;
  });

  window.addEventListener("keyup", (e) => {
    if (e.key === "w" || e.key === "s") input.forward = 0;
    if (e.key === "a" || e.key === "d") input.right = 0;
  });

  const walkSpeed = 0.24;

  let camPos = camera.position.clone();
  let camTarget = new BABYLON.Vector3();
  const followTime = 0.125;

  /* ============================================================
     TOOL SYSTEM
     ============================================================ */

  const toolDeclarations = [
    { type: "Grab",      name: "Grab" },
    { type: "Copy",      name: "Clone" },
    { type: "Delete",    name: "Delete" },
    { type: "SlingShot", name: "SlingShot" },
    { type: "Bomb",      name: "Explosives" }
  ];

  const ToolBehaviors = {};

  const toolBar = document.createElement("div");
  toolBar.style.position = "absolute";
  toolBar.style.bottom = "10px";
  toolBar.style.left = "10px";
  toolBar.style.display = "flex";
  toolBar.style.gap = "0px";
  toolBar.style.zIndex = "50";
  document.body.appendChild(toolBar);

  let selectedToolIndex = -1;
  const toolButtons = [];

  function createToolButton(tool, index) {
    const btn = document.createElement("div");
    btn.style.width = "100px";
    btn.style.height = "100px";
    btn.style.background = "rgba(165,165,165,0.4)";
    btn.style.border = "none";
    btn.style.margin = "0";
    btn.style.fontFamily = "Arimo, sans-serif";
    btn.style.fontStyle = "italic";
    btn.style.fontWeight = "bold";
    btn.style.color = "white";
    btn.style.display = "flex";
    btn.style.flexDirection = "column";
    btn.style.justifyContent = "center";
    btn.style.alignItems = "center";
    btn.style.position = "relative";
    btn.style.cursor = "pointer";
    btn.style.userSelect = "none";

    const label = document.createElement("div");
    label.innerText = tool.name;
    label.style.fontSize = "18px";
    label.style.textShadow = "0 0 2px black";
    btn.appendChild(label);

    const num = document.createElement("div");
    num.innerText = (index + 1).toString();
    num.style.position = "absolute";
    num.style.bottom = "4px";
    num.style.left = "6px";
    num.style.fontSize = "16px";
    num.style.textShadow = "0 0 2px black";
    btn.appendChild(num);

    btn.onclick = () => {
      if (selectedToolIndex === index) {
        selectedToolIndex = -1;
        updateToolHighlight();
        if (sounds.tool_ping) sounds.tool_ping.play();
      } else {
        selectTool(index);
      }
    };

    toolBar.appendChild(btn);
    return btn;
  }

  toolDeclarations.forEach((tool, i) => {
    toolButtons.push(createToolButton(tool, i));
  });

  function updateToolHighlight() {
    toolButtons.forEach((btn, i) => {
      btn.style.outline = (i === selectedToolIndex)
        ? "3px solid yellow"
        : "none";
    });
  }

  function selectTool(i) {
    selectedToolIndex = i;
    updateToolHighlight();
    if (sounds.tool_ping) sounds.tool_ping.play();
  }

  updateToolHighlight();

  // NUMBER KEY TOGGLE
  window.addEventListener("keydown", e => {
    const n = parseInt(e.key);
    if (!isNaN(n) && n >= 1 && n <= toolButtons.length) {
      const index = n - 1;

      if (selectedToolIndex === index) {
        selectedToolIndex = -1;
        updateToolHighlight();
        if (sounds.tool_ping) sounds.tool_ping.play();
      } else {
        selectTool(index);
      }
    }
  });

  function currentToolType() {
    if (selectedToolIndex === -1) return null;
    return toolDeclarations[selectedToolIndex].type;
  }

  function getMouseHit() {
    const pick = scene.pick(scene.pointerX, scene.pointerY);
    return pick && pick.hit ? pick : null;
  }

  const highlight = new BABYLON.HighlightLayer("hl", scene);

  function makeDraggable(mesh) {
    mesh.draggable = true;
  }

  function alignValue(v) {
    return v >= 0 ? Math.floor(v) : Math.ceil(v);
  }

  function alignVector3(vec) {
    return new BABYLON.Vector3(
      alignValue(vec.x),
      alignValue(vec.y),
      alignValue(vec.z)
    );
  }

  const projectiles = [];

  /* ============================================================
     HEAD FORWARD VECTOR
     ============================================================ */

  function getHeadForward() {
    const m = model.getWorldMatrix();
    const forward = BABYLON.Vector3.TransformNormal(
      new BABYLON.Vector3(0, 0, -1),
      m
    );
    forward.y = 0;
    return forward.normalize();
  }

  /* ============================================================
     SLINGSHOT PROJECTILE
     ============================================================ */

  function spawnProjectile(options) {
    const { radius, color, life, speed, isBomb } = options;

    const forward = getHeadForward().negate();

    const startPos = new BABYLON.Vector3(
      rig.position.x,
      rig.position.y + 3.5,
      rig.position.z
    ).add(forward.scale(2));

    const mesh = BABYLON.MeshBuilder.CreateSphere("proj", { diameter: radius * 2 }, scene);
    const mat = new BABYLON.StandardMaterial("projMat", scene);
    mat.diffuseColor = color;
    mat.specularColor = new BABYLON.Color3(0,0,0);
    mesh.material = mat;

    const body = new CANNON.Body({
      mass: 1,
      material: groundMatPhys,
      linearDamping: 0.1,
      angularDamping: 0.1
    });
    body.addShape(new CANNON.Sphere(radius));
    body.position.set(startPos.x, startPos.y, startPos.z);

    body.velocity.set(
      forward.x * speed,
      2,
      forward.z * speed
    );

    world.addBody(body);

    projectiles.push({ mesh, body, life, isBomb });
  }

  /* ============================================================
     EXPLOSION
     ============================================================ */

  function explodeAt(position, radius, force) {
    const explosion = BABYLON.MeshBuilder.CreateSphere("explosion", { diameter: radius * 2 }, scene);

    const mat = new BABYLON.StandardMaterial("explosionMat", scene);
    mat.diffuseColor = new BABYLON.Color3(1, 0, 0);
    mat.emissiveColor = new BABYLON.Color3(1, 0, 0);
    mat.disableLighting = true;
    explosion.material = mat;
    explosion.position.copyFrom(position);

    if (sounds.explosion) sounds.explosion.play();

    scene.meshes.forEach(m => {
      if (!m.draggable) return;

      const bounding = m.getBoundingInfo().boundingSphere;
      const center = bounding.centerWorld;
      const dist = BABYLON.Vector3.Distance(center, position);

      if (dist < radius + bounding.radius) {
        const dir = center.subtract(position).normalize();
        m.position.addInPlace(dir.scale(force / dist));
      }
    });

    const playerPos = rig.position.clone();
    const distToPlayer = BABYLON.Vector3.Distance(playerPos, position);

    if (distToPlayer <= radius) {
      if (sounds.ouch) sounds.ouch.play();
      rig.position.set(0, 5, 0);
      playerBody.position.set(0, 10, 0);
      playerBody.velocity.set(0, 0, 0);
    }

    setTimeout(() => explosion.dispose(), 300);
  }

  /* ============================================================
     TOOL BEHAVIORS
     ============================================================ */

  let draggedMesh = null;
  let dragOffset = null;

  ToolBehaviors.Grab = {
    pointerDown(pick) {
      if (!pick || !pick.pickedMesh || !pick.pickedMesh.draggable) return;
      draggedMesh = pick.pickedMesh;
      dragOffset = draggedMesh.position.subtract(pick.pickedPoint);
      highlight.addMesh(draggedMesh, BABYLON.Color3.Yellow());
    },
    pointerMove(pick) {
      if (!draggedMesh || !pick) return;
      const pos = pick.pickedPoint.add(dragOffset);
      draggedMesh.position.copyFrom(alignVector3(pos));
    },
    pointerUp() {
      if (draggedMesh) {
        highlight.removeMesh(draggedMesh);
        draggedMesh = null;
      }
    }
  };

  ToolBehaviors.Copy = {
    pointerDown(pick) {
      if (!pick || !pick.pickedMesh || !pick.pickedMesh.draggable) return;
      if (sounds.tool_ping) sounds.tool_ping.play();

      const original = pick.pickedMesh;
      const clone = original.clone(original.name + "_clone");
      clone.position.copyFrom(original.position);
      makeDraggable(clone);
      draggedMesh = clone;
      dragOffset = new BABYLON.Vector3(0,0,0);
      highlight.addMesh(draggedMesh, BABYLON.Color3.Yellow());
    },
    pointerMove(pick) {
      if (!draggedMesh || !pick) return;
      draggedMesh.position.copyFrom(alignVector3(pick.pickedPoint));
    },
    pointerUp() {
      if (draggedMesh) {
        highlight.removeMesh(draggedMesh);
        draggedMesh = null;
      }
    }
  };

  ToolBehaviors.Delete = {
    pointerDown(pick) {
      if (!pick || !pick.pickedMesh || !pick.pickedMesh.draggable) return;
      if (sounds.snap) sounds.snap.play();
      highlight.removeMesh(pick.pickedMesh);
      pick.pickedMesh.dispose();
    },
    pointerMove() {},
    pointerUp() {}
  };

  ToolBehaviors.SlingShot = {
    pointerDown() {
      if (sounds.slingshot) sounds.slingshot.play();
      spawnProjectile({
        radius: 1,
        color: new BABYLON.Color3(0.7,0.7,0.7),
        life: 10,
        speed: 40,
        isBomb: false
      });
    },
    pointerMove() {},
    pointerUp() {}
  };

  ToolBehaviors.Bomb = {
    pointerDown() {
      if (sounds.tool_ping) sounds.tool_ping.play();
      if (sounds.bomb_tick) sounds.bomb_tick.play();

      const pos = new BABYLON.Vector3(
        rig.position.x,
        rig.position.y + 1,
        rig.position.z
      );

      const mesh = BABYLON.MeshBuilder.CreateSphere("bomb", { diameter: 2 }, scene);
      const mat = new BABYLON.StandardMaterial("bombMat", scene);
      mat.diffuseColor = new BABYLON.Color3(0,0,0);
      mat.specularColor = new BABYLON.Color3(0.1,0.1,0.1);
      mat.ambientColor = new BABYLON.Color3(0.2,0.2,0.2);
      mat.disableLighting = false;
      mesh.material = mat;
      mesh.position.copyFrom(pos);

      const body = new CANNON.Body({
        mass: 1,
        material: groundMatPhys
      });
      body.addShape(new CANNON.Sphere(1));
      body.position.set(pos.x, pos.y, pos.z);
      world.addBody(body);

      const bomb = {
        mesh,
        body,
        life: 10,
        isBomb: true
      };

      projectiles.push(bomb);
    },
    pointerMove() {},
    pointerUp() {}
  };

  let toolPointerDown = false;

  canvas.addEventListener("pointerdown", (e) => {
    if (e.button !== 0) return;
    toolPointerDown = true;
    const pick = getMouseHit();
    const toolType = currentToolType();
    const behavior = ToolBehaviors[toolType];
    if (behavior && behavior.pointerDown) {
      behavior.pointerDown(pick);
    }
  });

  canvas.addEventListener("pointerup", (e) => {
    if (e.button !== 0) return;
    toolPointerDown = false;
    const toolType = currentToolType();
    const behavior = ToolBehaviors[toolType];
    if (behavior && behavior.pointerUp) {      behavior.pointerUp();
    }
  });

  canvas.addEventListener("pointermove", () => {
    if (!toolPointerDown) return;
    const pick = getMouseHit();
    const toolType = currentToolType();
    const behavior = ToolBehaviors[toolType];
    if (behavior && behavior.pointerMove) {
      behavior.pointerMove(pick);
    }
  });

  /* ============================================================
     MAIN UPDATE LOOP
     ============================================================ */

scene.onReadyObservable.add(() => {
  console.log("Scene ready — loading sounds");

  loadSound("footsteps", "...", { loop: true, volume: 0.6 });
  loadSound("slingshot", "...");
  loadSound("tool_ping", "...");
  loadSound("explosion", "...");
  loadSound("ouch", "...");
  loadSound("snap", "...");
  loadSound("bomb_tick", "...", { loop: true, volume: 0.4 });
  loadSound("ui_click", "...");
});


  scene.onBeforeRenderObservable.add(() => {
    const dt = engine.getDeltaTime() / 1000;
    const fixedTimeStep = 1 / 60;

    const forward = new BABYLON.Vector3(Math.sin(camYaw), 0, Math.cos(camYaw));
    const right = new BABYLON.Vector3(
      Math.sin(camYaw + Math.PI / 2),
      0,
      Math.cos(camYaw + Math.PI / 2)
    );

    let move = forward.scale(input.forward).add(right.scale(input.right));

    // Movement + footsteps
    const isMoving = move.length() > 0.01;
    const onGround = playerBody.position.y <= rig.position.y + 0.2;

    if (isMoving && onGround) {
      if (!sounds.footsteps.isPlaying) sounds.footsteps.play();
    } else {
      if (sounds.footsteps.isPlaying) sounds.footsteps.stop();
    }

    if (isMoving) {
      move.normalize();
      rig.position.addInPlace(move.scale(walkSpeed));

      const targetAngle = Math.atan2(move.x, move.z);
      model.rotation.y = BABYLON.Scalar.Lerp(model.rotation.y, targetAngle, 0.15);
    }

    // Sync physics body to rig XZ
    playerBody.position.x = rig.position.x;
    playerBody.position.z = rig.position.z;

    // Physics step
    world.step(fixedTimeStep, dt, 3);

    // Sync rig to physics body
    rig.position.x = playerBody.position.x;
    rig.position.y = playerBody.position.y - capsuleHeight / 2 + 1;
    rig.position.z = playerBody.position.z;

    // Camera follow
    const headPos = new BABYLON.Vector3(
      rig.position.x,
      rig.position.y + 3.5,
      rig.position.z
    );

    const desiredCamPos = new BABYLON.Vector3(
      headPos.x + Math.sin(camYaw) * Math.cos(camPitch) * camDistance,
      headPos.y + Math.sin(camPitch) * camDistance,
      headPos.z + Math.cos(camYaw) * Math.cos(camPitch) * camDistance
    );

    camPos = BABYLON.Vector3.Lerp(camPos, desiredCamPos, dt / followTime);
    camera.position.copyFrom(camPos);

    camTarget = BABYLON.Vector3.Lerp(camTarget, headPos, dt / followTime);
    camera.setTarget(camTarget);

    // Projectiles update
    for (let i = projectiles.length - 1; i >= 0; i--) {
      const p = projectiles[i];
      p.life -= dt;
      p.mesh.position.set(p.body.position.x, p.body.position.y, p.body.position.z);

      if (p.life <= 0) {
        if (p.isBomb) {
          if (sounds.bomb_tick && sounds.bomb_tick.isPlaying) sounds.bomb_tick.stop();
          explodeAt(p.mesh.position.clone(), 10, 40);
        }
        world.removeBody(p.body);
        p.mesh.dispose();
        projectiles.splice(i, 1);
      }
    }
  });

  return scene;
}

// ============================================================
// START ENGINE
// ============================================================

const scene = createScene();
engine.runRenderLoop(() => scene.render());
window.addEventListener("resize", () => engine.resize());
</script>

</body>
</html>
