<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Interactive3D</title>
  <link rel="icon" type="image/x-icon" href="https://raw.githubusercontent.com/yeahbuildsstuff/GameAssetServiceRepo/main/appicon.ico">
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
  <script src="https://unpkg.com/fengari-web/dist/fengari-web.js"></script>

  <style>
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      overflow: hidden;
      cursor: url("https://raw.githubusercontent.com/yeahbuildsstuff/GameAssetServiceRepo/main/cursor.cur"), auto;
    }

    #renderCanvas {
      width: 100%;
      height: 100%;
      display: block;
      cursor: url("https://raw.githubusercontent.com/yeahbuildsstuff/GameAssetServiceRepo/main/cursor.cur"), auto;
    }

    .uiBtn {
      background: rgba(165,165,165,0.4);
      border: none;
      font-family: "Arimo", sans-serif;
      font-style: italic;
      font-weight: bold;
      color: rgb(255,255,255);
      cursor: pointer;
      font-size: 14px;
      -webkit-text-stroke: 1px black;
      text-shadow: 0 0 1px black;
      padding: 0;
      height: 25px;
      width: 100px;
    }

    .btnText {
      display: inline-block;
      padding: 2px 6px;
    }
  </style>
</head>
<body>

<canvas id="renderCanvas"></canvas>

<script id="placeData" type="text/plain">
<!DOCTYPE placeXML>
<place>

  <config>
    <title>Game</title>
    <CharacterColors
      ArmHeadColorR="245" ArmHeadColorG="205" ArmHeadColorB="48"
      TorsoColorR="128" TorsoColorG="187" TorsoColorB="219"
      LegsColorR="164" LegsColorG="189" LegsColorB="71"
    />
  </config>

  <part
    name="Baseplate"
    r="75" g="151" b="75"
    px="0" py="0" pz="0"
    sx="64" sy="1" sz="64"
    shape="Block"
    draggable="false"
    collision="true"
    anchored="true"
    transparency="0"
  />

  <texture
    adornee="Baseplate"
    name="Texture"
    studspertilex="1"
    studspertiley="1"
    texture='url("https://raw.githubusercontent.com/yeahbuildsstuff/GameAssetServiceRepo/main/Surfaces/Studs.png")'
    face="Top"
    transparency="0"
  />

<texture
    adornee="Baseplate"
    name="Texture"
    studspertilex="1"
    studspertiley="1"
    texture='url("https://raw.githubusercontent.com/yeahbuildsstuff/GameAssetServiceRepo/main/Surfaces/Inlet.png")'
    face="Bottom"
    transparency="0"
  />

  
</place>

<TOOL_INSTANCES>
<jscript>
window.toolDeclarations = [
    { type: "Grab",           name: "Grab" },
    { type: "Copy",           name: "Clone" },
    { type: "Delete",         name: "Delete" },
    { type: "SlingShot",      name: "SlingShot" },
   
  ];
</jscript>
</TOOL_INSTANCES>
</script>

<div id="topButtons" style="
  position: absolute;
  top: 0px;
  left: 0px;
  display: flex;
  gap: 0px;
  z-index: 20;
">
  <div style="width:100px"></div>

  <button id="helpBtn" class="uiBtn"><span class="btnText">Help</span></button>
  <button id="fullscreenBtn" class="uiBtn"><span class="btnText">Fullscreen</span></button>
  <button id="exitBtn" class="uiBtn"><span class="btnText">Exit</span></button>
</div>

<div id="helpPopup" style="
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 420px;
  max-height: 70%;
  overflow-y: auto;
  background: #fff8c6;
  border: 1px solid black;
  padding: 20px;
  display: none;
  z-index: 30;
"></div>

<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);

async function loadHelpFile(url) {
  const text = await fetch(url).then(r => r.text());
  return parseHelpFormat(text);
}

function parseHelpFormat(raw) {
  const lines = raw.split("\n");
  const html = [];
  for (let line of lines) {
    line = line.trim();
    if (!line) continue;
    if (line.startsWith("<line.empty>")) {
      html.push("<div style='height:10px'></div>");
      continue;
    }
    if (line.startsWith("<line.new>")) {
      const match = line.match(/<line\.new>\s*"([^"]+)",([^,]+),([^,]+),(.+)/);
      if (match) {
        const text = match[1];
        const weight = match[2];
        const size = match[3];
        const font = match[4];
        html.push(`
          <div style="
            font-family:${font};
            font-size:${size}px;
            font-weight:${weight === 'Bold' ? 'bold' : 'normal'};
            margin-bottom:6px;
          ">
            ${text}
          </div>
        `);
      }
    }
  }
  return html.join("");
}

function showHelpPopup(html) {
  const popup = document.getElementById("helpPopup");
  popup.innerHTML = html;
  popup.style.display = "block";
}

function hideHelpPopup() {
  const popup = document.getElementById("helpPopup");
  popup.style.display = "none";
}

const world = new CANNON.World();
world.gravity.set(0, -157.12, 0);
world.broadphase = new CANNON.NaiveBroadphase();
world.solver.iterations = 10;

const groundMatPhys = new CANNON.Material("groundMatPhys");
const playerMatPhys = new CANNON.Material("playerMatPhys");
world.addContactMaterial(new CANNON.ContactMaterial(
  groundMatPhys,
  playerMatPhys,
  { friction: 1.0, restitution: 0.0 }
));

let makeDraggableRef = null;

window.namedParts = {};
window.luaScripts = [];

function extractUrlAttr(attr) {
  if (!attr) return null;
  const m = attr.match(/url\(["']?(.*?)["']?\)/i);
  return m ? m[1] : attr;
}

function getFaceNormal(face) {
  switch ((face || "").toLowerCase()) {
    case "top": return new BABYLON.Vector3(0, 1, 0);
    case "bottom": return new BABYLON.Vector3(0, -1, 0);
    case "front": return new BABYLON.Vector3(0, 0, -1);
    case "back": return new BABYLON.Vector3(0, 0, 1);
    case "left": return new BABYLON.Vector3(-1, 0, 0);
    case "right": return new BABYLON.Vector3(1, 0, 0);
    default: return new BABYLON.Vector3(0, 1, 0);
  }
}

function getFaceSize(mesh, face) {
  const bbox = mesh.getBoundingInfo().boundingBox;
  const ext = bbox.extendSizeWorld;
  switch ((face || "").toLowerCase()) {
    case "top":
    case "bottom":
      return new BABYLON.Vector2(ext.x * 2, ext.z * 2);
    case "front":
    case "back":
      return new BABYLON.Vector2(ext.x * 2, ext.y * 2);
    case "left":
    case "right":
      return new BABYLON.Vector2(ext.z * 2, ext.y * 2);
    default:
      return new BABYLON.Vector2(ext.x * 2, ext.z * 2);
  }
}

function getFacePosition(mesh, face) {
  const bbox = mesh.getBoundingInfo().boundingBox;
  const center = bbox.centerWorld;
  const extents = bbox.extendSizeWorld;
  const n = getFaceNormal(face);
  return new BABYLON.Vector3(
    center.x + n.x * extents.x + n.x * 0.01,
    center.y + n.y * extents.y + n.y * 0.01,
    center.z + n.z * extents.z + n.z * 0.01
  );
}

function getFaceRotation(face) {
  switch ((face || "").toLowerCase()) {
    case "top":    return new BABYLON.Vector3(Math.PI / 2, 0, 0);
    case "bottom": return new BABYLON.Vector3(-Math.PI / 2, 0, 0);
    case "front":  return new BABYLON.Vector3(0, 0, 0);
    case "back":   return new BABYLON.Vector3(0, Math.PI, 0);
    case "left":   return new BABYLON.Vector3(0, -Math.PI / 2, 0);
    case "right":  return new BABYLON.Vector3(0, Math.PI / 2, 0);
    default:       return new BABYLON.Vector3(0, 0, 0);
  }
}

function createFacePlane(target, face, scene) {
  const size2D = getFaceSize(target, face);
  const plane = BABYLON.MeshBuilder.CreatePlane("facePlane", {
    width: size2D.x,
    height: size2D.y
  }, scene);
  plane.position = getFacePosition(target, face);
  plane.rotation = getFaceRotation(face);
  plane.parent = target;
  plane.isPickable = false;
  return plane;
}

const luaVMs = [];

function createLuaVM(code) {
  const lines = code.split("\n").map(l => l.trim());
  return {
    lines,
    pc: 0,
    waitTime: 0,
    loopStack: [],
    done: false
  };
}

function stepLuaVM(vm, dt) {
  if (vm.done) return;
  if (vm.waitTime > 0) {
    vm.waitTime -= dt;
    if (vm.waitTime > 0) return;
  }
  while (vm.pc < vm.lines.length) {
    let line = vm.lines[vm.pc].trim();
    if (!line || line.startsWith("--")) {
      vm.pc++;
      continue;
    }
    if (/^while\s+true\s+do/.test(line)) {
      vm.loopStack.push({ type: "while", startPc: vm.pc + 1 });
      vm.pc++;
      continue;
    }
    let forMatch = line.match(/^for\s+([a-zA-Z_]\w*)\s*=\s*(\d+)\s*,\s*(\d+)\s*do/);
    if (forMatch) {
      const varName = forMatch[1];
      const start = parseInt(forMatch[2], 10);
      const end = parseInt(forMatch[3], 10);
      vm.loopStack.push({
        type: "for",
        varName,
        current: start,
        end,
        startPc: vm.pc + 1
      });
      vm[varName] = start;
      vm.pc++;
      continue;
    }
    if (line === "end") {
      const frame = vm.loopStack.pop();
      if (!frame) {
        vm.pc++;
        continue;
      }
      if (frame.type === "while") {
        vm.loopStack.push(frame);
        vm.pc = frame.startPc;
        continue;
      } else if (frame.type === "for") {
        frame.current++;
        if (frame.current <= frame.end) {
          vm.loopStack.push(frame);
          vm[frame.varName] = frame.current;
          vm.pc = frame.startPc;
          continue;
        } else {
          vm.pc++;
          continue;
        }
      }
    }
    let waitMatch = line.match(/^wait\(\s*([\d.]+)\s*\)/);
    if (waitMatch) {
      const seconds = parseFloat(waitMatch[1]);
      vm.waitTime = seconds;
      vm.pc++;
      return;
    }
    let assignMatch = line.match(/^([A-Za-z_]\w*)\.(p[xyz]|s[xyz])\s*=\s*([A-Za-z_]\w*)\.(p[xyz]|s[xyz])\s*([\+\-])\s*([\d.]+)/);
    if (assignMatch) {
      const partNameL = assignMatch[1];
      const propL = assignMatch[2];
      const partNameR = assignMatch[3];
      const propR = assignMatch[4];
      const op = assignMatch[5];
      const val = parseFloat(assignMatch[6]);
      const partL = window.namedParts[partNameL];
      const partR = window.namedParts[partNameR];
      if (partL && partR) {
        function getProp(part, prop) {
          if (prop === "px") return part.position.x;
          if (prop === "py") return part.position.y;
          if (prop === "pz") return part.position.z;
          if (prop === "sx") return part.scaling.x;
          if (prop === "sy") return part.scaling.y;
          if (prop === "sz") return part.scaling.z;
          return 0;
        }
        function setProp(part, prop, v) {
          if (prop === "px") part.position.x = v;
          if (prop === "py") part.position.y = v;
          if (prop === "pz") part.position.z = v;
          if (prop === "sx") part.scaling.x = v;
          if (prop === "sy") part.scaling.y = v;
          if (prop === "sz") part.scaling.z = v;
          if (part.physicsBody && (prop === "px" || prop === "py" || prop === "pz")) {
            part.physicsBody.position.set(part.position.x, part.position.y, part.position.z);
            part.physicsBody.velocity.set(0,0,0);
          }
        }
        let base = getProp(partR, propR);
        let result = op === "+" ? base + val : base - val;
        setProp(partL, propL, result);
      }
      vm.pc++;
      continue;
    }
    let assignSimple = line.match(/^([A-Za-z_]\w*)\.(p[xyz]|s[xyz])\s*=\s*([\d.]+)/);
    if (assignSimple) {
      const partName = assignSimple[1];
      const prop = assignSimple[2];
      const val = parseFloat(assignSimple[3]);
      const part = window.namedParts[partName];
      if (part) {
        if (prop === "px") part.position.x = val;
        if (prop === "py") part.position.y = val;
        if (prop === "pz") part.position.z = val;
        if (prop === "sx") part.scaling.x = val;
        if (prop === "sy") part.scaling.y = val;
        if (prop === "sz") part.scaling.z = val;
        if (part.physicsBody && (prop === "px" || prop === "py" || prop === "pz")) {
          part.physicsBody.position.set(part.position.x, part.position.y, part.position.z);
          part.physicsBody.velocity.set(0,0,0);
        }
      }
      vm.pc++;
      continue;
    }
    vm.pc++;
  }
  if (vm.pc >= vm.lines.length && vm.loopStack.length === 0) {
    vm.done = true;
  }
}

function startLuaScheduler() {
  const interval = 50;
  setInterval(() => {
    const dt = interval / 1000;
    for (const vm of luaVMs) {
      stepLuaVM(vm, dt);
    }
  }, interval);
}

function LOAD_PLACE_FROM_XML(xmlString, scene) {
  const parser = new DOMParser();
  const xml = parser.parseFromString(xmlString, "text/xml");

  const config = xml.getElementsByTagName("config")[0];

  let characterColors = {
    armHead: new BABYLON.Color3(245/255, 205/255, 48/255),
    torso:   new BABYLON.Color3(128/255, 187/255, 219/255),
    legs:    new BABYLON.Color3(164/255, 189/255, 71/255)
  };

  if (config) {
    const titleNode = config.getElementsByTagName("title")[0];
    if (titleNode && titleNode.textContent) {
      document.title = titleNode.textContent + " - Interactive3D";
    }

    const charNode = config.getElementsByTagName("CharacterColors")[0];
    if (charNode) {
      characterColors = {
        armHead: new BABYLON.Color3(
          parseFloat(charNode.getAttribute("ArmHeadColorR"))/255,
          parseFloat(charNode.getAttribute("ArmHeadColorG"))/255,
          parseFloat(charNode.getAttribute("ArmHeadColorB"))/255
        ),
        torso: new BABYLON.Color3(
          parseFloat(charNode.getAttribute("TorsoColorR"))/255,
          parseFloat(charNode.getAttribute("TorsoColorG"))/255,
          parseFloat(charNode.getAttribute("TorsoColorB"))/255
        ),
        legs: new BABYLON.Color3(
          parseFloat(charNode.getAttribute("LegsColorR"))/255,
          parseFloat(charNode.getAttribute("LegsColorG"))/255,
          parseFloat(charNode.getAttribute("LegsColorB"))/255
        )
      };
    }
  }

  window.characterColors = characterColors;

  const parts = xml.getElementsByTagName("part");
  for (let i = 0; i < parts.length; i++) {
    const p = parts[i];

    const name = p.getAttribute("name") || ("Part_" + i);

    const r = parseFloat(p.getAttribute("r") || "200") / 255;
    const g = parseFloat(p.getAttribute("g") || "200") / 255;
    const b = parseFloat(p.getAttribute("b") || "200") / 255;

    const px = parseFloat(p.getAttribute("px") || "0");
    const py = parseFloat(p.getAttribute("py") || "0");
    const pz = parseFloat(p.getAttribute("pz") || "0");

    const sx = parseFloat(p.getAttribute("sx") || "4");
    const sy = parseFloat(p.getAttribute("sy") || "1");
    const sz = parseFloat(p.getAttribute("sz") || "4");

    const shape = (p.getAttribute("shape") || "Block");
    const draggable = (p.getAttribute("draggable") === "true");
    const collision = (p.getAttribute("collision") !== "false");
    const anchored = (p.getAttribute("anchored") === "true");
    const transparency = parseFloat(p.getAttribute("transparency") || "0");

    let mesh;
    if (shape === "Sphere") {
      mesh = BABYLON.MeshBuilder.CreateSphere(name, {
        diameterX: sx,
        diameterY: sy,
        diameterZ: sz
      }, scene);
    } else {
      mesh = BABYLON.MeshBuilder.CreateBox(name, {
        width: sx,
        height: sy,
        depth: sz
      }, scene);
    }

    mesh.position = new BABYLON.Vector3(px, py, pz);

    const mat = new BABYLON.StandardMaterial(name + "_mat", scene);
    mat.diffuseColor = new BABYLON.Color3(r, g, b);
    mat.specularColor = new BABYLON.Color3(0, 0, 0);
    mat.alpha = 1 - transparency;
    mesh.material = mat;

    mesh.isPickable = true;
    mesh.draggable = draggable;

    if (collision) {
      const halfExtents = new CANNON.Vec3(sx / 2, sy / 2, sz / 2);
      const shapeBox = new CANNON.Box(halfExtents);

      const body = new CANNON.Body({
        mass: anchored ? 0 : 1,
        material: groundMatPhys
      });

      body.addShape(shapeBox);
      body.position.set(px, py, pz);
      world.addBody(body);
      mesh.physicsBody = body;
    }

    if (draggable && makeDraggableRef) {
      makeDraggableRef(mesh);
    }

    window.namedParts[name] = mesh;
  }

  const textures = xml.getElementsByTagName("texture");
  for (let i = 0; i < textures.length; i++) {
    const t = textures[i];
    const adorneeName = t.getAttribute("adornee");
    const target = window.namedParts[adorneeName];
    if (!target) continue;

    const texAttr = t.getAttribute("texture");
    const texUrl = extractUrlAttr(texAttr);
    if (!texUrl) continue;

    const face = t.getAttribute("face") || "Top";
    const studsX = parseFloat(t.getAttribute("studspertilex") || "1");
    const studsY = parseFloat(t.getAttribute("studspertiley") || "1");
    const transparency = parseFloat(t.getAttribute("transparency") || "0");

    const plane = createFacePlane(target, face, scene);
    const mat = new BABYLON.StandardMaterial("textureMat_" + i, scene);
    const tex = new BABYLON.Texture(texUrl, scene);
    const size2D = getFaceSize(target, face);

    tex.uScale = size2D.x / studsX;
    tex.vScale = size2D.y / studsY;
    tex.hasAlpha = true;

    mat.diffuseTexture = tex;
    mat.backFaceCulling = false;
    mat.alpha = 1 - transparency;
    mat.specularColor = new BABYLON.Color3(0,0,0);
    mat.emissiveColor = new BABYLON.Color3(0,0,0);

    plane.material = mat;
  }

  const decals = xml.getElementsByTagName("decal");
  for (let i = 0; i < decals.length; i++) {
    const d = decals[i];
    const adorneeName = d.getAttribute("adornee");
    const target = window.namedParts[adorneeName];
    if (!target) continue;

    const texAttr = d.getAttribute("texture");
    const texUrl = extractUrlAttr(texAttr);
    if (!texUrl) continue;

    const face = d.getAttribute("face") || "Top";
    const transparency = parseFloat(d.getAttribute("transparency") || "0");

    const plane = createFacePlane(target, face, scene);
    const mat = new BABYLON.StandardMaterial("decalMat_" + i, scene);
    const tex = new BABYLON.Texture(texUrl, scene);

    tex.hasAlpha = true;
    mat.diffuseTexture = tex;
    mat.backFaceCulling = false;
    mat.zOffset = -2;
    mat.alpha = 1 - transparency;
    mat.specularColor = new BABYLON.Color3(0,0,0);
    mat.emissiveColor = new BABYLON.Color3(0,0,0);

    plane.material = mat;
  }

  const luaNodes = xml.getElementsByTagName("luascript");
  for (let i = 0; i < luaNodes.length; i++) {
    const node = luaNodes[i];
    const code = node.textContent || "";
    const vm = createLuaVM(code);
    luaVMs.push(vm);
  }

  if (luaVMs.length > 0) startLuaScheduler();
}

function createScene() {
  const scene = new BABYLON.Scene(engine);

  scene.clearColor = new BABYLON.Color3(1, 1, 1);

  const skybox = BABYLON.MeshBuilder.CreateBox("skyBox", { size: 2000 }, scene);
  const skyboxMaterial = new BABYLON.StandardMaterial("skyBoxMat", scene);

  skyboxMaterial.backFaceCulling = false;
  skyboxMaterial.disableLighting = true;

  skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture(
    "https://raw.githubusercontent.com/yeahbuildsstuff/GameAssetServiceRepo/main/null_plainsky512/null_plainsky512",
    scene,
    ["_rt.jpg","_up.jpg","_ft.jpg","_lf.jpg","_dn.jpg","_bk.jpg"]
  );

  skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
  skybox.material = skyboxMaterial;
  skybox.infiniteDistance = true;

  const spriteManagerSun = new BABYLON.SpriteManager(
    "sunManager",
    "https://raw.githubusercontent.com/yeahbuildsstuff/GameAssetServiceRepo/main/sun.png",
    1,
    { width: 512, height: 512 },
    scene
  );

  spriteManagerSun.renderingGroupId = 0;

  const sunSprite = new BABYLON.Sprite("sun", spriteManagerSun);
  sunSprite.size = 160;
  sunSprite.position = new BABYLON.Vector3(200, 100, 200);
  sunSprite.isPickable = false;
  sunSprite.renderingGroupId = 0;

  const sun = new BABYLON.DirectionalLight("sun", new BABYLON.Vector3(-1, -1, -1), scene);
  sun.position = new BABYLON.Vector3(10, 10, -10);
  sun.intensity = 0.23335;

  const ambient = new BABYLON.HemisphericLight("ambient", new BABYLON.Vector3(0, 1, 0), scene);
  ambient.diffuse = new BABYLON.Color3(1, 1, 1);
  ambient.specular = new BABYLON.Color3(0, 0, 0);
  ambient.groundColor = new BABYLON.Color3(1, 1, 1);
  ambient.intensity = 0.8;

  const placeTag = document.getElementById("placeData");
  if (placeTag) {
    LOAD_PLACE_FROM_XML(placeTag.textContent, scene);
  }

  const rig = new BABYLON.TransformNode("rig", scene);
  rig.position.y = 5;

  const spawnPoint = rig.position.clone();

  const model = new BABYLON.TransformNode("model", scene);
  model.parent = rig;

  let id = 0;
  function part(name, w, h, d, y, x = 0, color) {
    const p = BABYLON.MeshBuilder.CreateBox(name + "_" + (id++), {
      width: w, height: h, depth: d
    }, scene);
    p.position.y = y;
    p.position.x = x;

    const mat = new BABYLON.StandardMaterial(name + "_mat", scene);
    mat.diffuseColor = color;
    mat.specularColor = new BABYLON.Color3(0, 0, 0);
    p.material = mat;

    p.parent = model;
    p.draggable = false;
    return p;
  }

  const brightYellow      = window.characterColors.armHead;
  const pastelBlue        = window.characterColors.torso;
  const brightYellowGreen = window.characterColors.legs;

  part("torso", 2, 2, 1, 2, 0, pastelBlue);
  part("leftLeg", 1, 2, 1, 0, -0.5, brightYellowGreen);
  part("rightLeg", 1, 2, 1, 0, 0.5, brightYellowGreen);
  part("leftArm", 1, 2, 1, 2, -1.5, brightYellow);
  part("rightArm", 1, 2, 1, 2, 1.5, brightYellow);

  BABYLON.SceneLoader.ImportMesh(
    "",
    "https://raw.githubusercontent.com/yeahbuildsstuff/GameAssetServiceRepo/main/",
    "head.obj",
    scene,
    function(meshes) {
      const headInner = meshes[0];
      headInner.scaling = new BABYLON.Vector3(1, 1, 1);
      headInner.rotation = new BABYLON.Vector3(0, Math.PI, 0);
      headInner.position = new BABYLON.Vector3(0, 3.5, 0);
      headInner.parent = model;

      const innerMat = new BABYLON.StandardMaterial("innerMat", scene);
      innerMat.diffuseColor = brightYellow;
      innerMat.specularColor = new BABYLON.Color3(0, 0, 0);
      headInner.material = innerMat;

      const headOuter = headInner.clone("headOuter");
      headOuter.parent = model;
      headOuter.scaling = new BABYLON.Vector3(1.002, 1.002, 1.002);

      const faceMat = new BABYLON.StandardMaterial("faceMat", scene);
      const faceTex = new BABYLON.Texture(
        "https://raw.githubusercontent.com/yeahbuildsstuff/GameAssetServiceRepo/main/defaultface.png",
        scene
      );

      faceTex.hasAlpha = true;
      faceMat.diffuseTexture = faceTex;
      faceMat.opacityTexture = faceTex;
      faceMat.emissiveColor = new BABYLON.Color3(1, 1, 1);
      faceMat.specularColor = new BABYLON.Color3(0, 0, 0);
      faceMat.backFaceCulling = false;

      headOuter.material = faceMat;
    }
  );

  const SFX_BASE = "https://raw.githubusercontent.com/yeahbuildsstuff/GameAssetServiceRepo/main/sounds/";
  const sounds = {};

  function loadSound(name, file, options = {}) {
    const player = new Tone.Player(SFX_BASE + file).toDestination();
    if (options.loop) player.loop = true;
    if (options.volumeDb !== undefined) player.volume.value = options.volumeDb;
    player._playing = false;
    sounds[name] = player;
  }

  let audioStarted = false;
  let bombTickInterval = null;

  function startBombTick() {
    if (bombTickInterval) return;
    bombTickInterval = setInterval(() => {
      const p = sounds.bomb_tick;
      if (p && p.loaded) {
        try { p.start(); } catch(e) {}
      }
    }, 500);
  }

  function stopBombTick() {
    if (!bombTickInterval) return;
    clearInterval(bombTickInterval);
    bombTickInterval = null;
  }

  function ensureAudioStarted() {
    if (!audioStarted) {
      Tone.start();
      audioStarted = true;

      loadSound("footsteps", "footsteps.mp3", { loop: true, volumeDb: -5 });
      loadSound("slingshot", "Rubberbandslingshot.wav", { volumeDb: -3 });
      loadSound("tool_ping", "electronicpingshort.wav", { volumeDb: -6 });
      loadSound("explosion", "Shoulderfiredrocket.wav", { volumeDb: -2 });
      loadSound("ouch", "KidsayingOuch.wav", { volumeDb: -4 });
      loadSound("snap", "snap.wav", { volumeDb: -4 });
      loadSound("bomb_tick", "clickfast.wav", { volumeDb: -10 });
      loadSound("ui_click", "SWITCH3.wav", { volumeDb: -8 });
      loadSound("rocket_launch", "Launchingrocket.wav", { volumeDb: -3 });
    }
  }

  window.addEventListener("pointerdown", ensureAudioStarted, { once: true });
  window.addEventListener("keydown", ensureAudioStarted, { once: true });

  document.getElementById("helpBtn").onclick = async () => {
    const p = sounds.ui_click;
    if (p && p.loaded) try { p.start(); } catch(e) {}
    const html = await loadHelpFile(
      "https://raw.githubusercontent.com/yeahbuildsstuff/GameAssetServiceRepo/main/text_files/Controls.help"
    );
    showHelpPopup(html);
  };

  document.getElementById("fullscreenBtn").onclick = () => {
    const p = sounds.ui_click;
    if (p && p.loaded) try { p.start(); } catch(e) {}
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen();
    } else {
      document.exitFullscreen();
    }
  };

  document.getElementById("exitBtn").onclick = () => {
    const p = sounds.ui_click;
    if (p && p.loaded) try { p.start(); } catch(e) {}
    window.location.href = "https://yeahbuildsstuff.github.io/gamemenuservice/";
  };

  document.addEventListener("keydown", e => {
    if (e.key === "Escape") {
      const p = sounds.ui_click;
      if (p && p.loaded) try { p.start(); } catch(e) {}
      hideHelpPopup();
    }
  });

  const capsuleRadius = 0.6;
  const capsuleHeight = 8.0;
  const capsuleOffset = 1.0;
  const cylHeight = capsuleHeight - 2 * capsuleRadius;

  const sphereTop = new CANNON.Sphere(capsuleRadius);
  const sphereBottom = new CANNON.Sphere(capsuleRadius);
  const cylinder = new CANNON.Cylinder(capsuleRadius, capsuleRadius, cylHeight, 8);

  const playerBody = new CANNON.Body({
    mass: 1,
    material: playerMatPhys,
    linearDamping: 0.9,
    angularDamping: 1.0
  });

  playerBody.addShape(sphereTop, new CANNON.Vec3(0, cylHeight / 2, 0));
  playerBody.addShape(sphereBottom, new CANNON.Vec3(0, -cylHeight / 2, 0));

  const q = new CANNON.Quaternion();
  q.setFromEuler(Math.PI / 2, 0, 0);
  playerBody.addShape(cylinder, new CANNON.Vec3(0, 0, 0), q);

  playerBody.position.set(
    rig.position.x,
    rig.position.y + capsuleHeight / 2 + capsuleOffset,
    rig.position.z
  );
  playerBody.fixedRotation = true;
  playerBody.updateMassProperties();
  world.addBody(playerBody);

  let camYaw = Math.PI / 2;
  let camPitch = Math.PI / 4;
  let camDistance = 15 / 1.4;

  const camera = new BABYLON.FreeCamera("cam", new BABYLON.Vector3(0, 5, -10), scene);
  camera.minZ = 0.1;

  let isMouseDown = false;
  canvas.addEventListener("pointerdown", () => isMouseDown = true);
  canvas.addEventListener("pointerup", () => isMouseDown = false);

  canvas.addEventListener("pointermove", (e) => {
    if (!isMouseDown) return;
    camYaw += e.movementX * 0.005;
    camPitch += e.movementY * 0.005;
  });

  const input = { forward: 0, right: 0 };

  camera.inertia = 0;
  camera.angularInertia = 0;
  camera.speed = 0;

  window.addEventListener("keydown", (e) => {
    if (e.key === "w") input.forward = -1;
    if (e.key === "s") input.forward = 1;
    if (e.key === "a") input.right = 1;
    if (e.key === "d") input.right = -1;

    if ((e.key === "r" || e.key === "R") && draggedMesh) {
      draggedMesh.rotation.y += Math.PI / 2;
      if (draggedMesh.physicsBody) {
        draggedMesh.physicsBody.position.set(
          draggedMesh.position.x,
          draggedMesh.position.y,
          draggedMesh.position.z
        );
        draggedMesh.physicsBody.velocity.set(0,0,0);
      }
    }
  });

  window.addEventListener("keyup", (e) => {
    if (e.key === "w" || e.key === "s") input.forward = 0;
    if (e.key === "a" || e.key === "d") input.right = 0;
  });

  const walkSpeed = 0.24;

  let camPos = camera.position.clone();
  let camTarget = new BABYLON.Vector3();
  const followTime = 0.125;

  if (!window.toolDeclarations) {
    window.toolDeclarations = [
      { type: "Grab",           name: "Grab" },
      { type: "Copy",           name: "Clone" },
      { type: "Delete",         name: "Delete" },
      { type: "SlingShot",      name: "SlingShot" },
      { type: "Bomb",           name: "Explosives" },
      { type: "RocketLauncher", name: "Rocket" }
    ];
  }

  const ToolBehaviors = {};

  const toolBar = document.createElement("div");
  toolBar.style.position = "absolute";
  toolBar.style.bottom = "10px";
  toolBar.style.left = "10px";
  toolBar.style.display = "flex";
  toolBar.style.gap = "0px";
  toolBar.style.zIndex = "50";
  document.body.appendChild(toolBar);

  let selectedToolIndex = -1;
  const toolButtons = [];

  function createToolButton(tool, index) {
    const btn = document.createElement("div");
    btn.style.width = "100px";
    btn.style.height = "100px";
    btn.style.background = "rgba(165,165,165,0.4)";
    btn.style.border = "none";
    btn.style.margin = "0";
    btn.style.fontFamily = "Arimo, sans-serif";
    btn.style.fontStyle = "italic";
    btn.style.fontWeight = "bold";
    btn.style.color = "white";
    btn.style.display = "flex";
    btn.style.flexDirection = "column";
    btn.style.justifyContent = "center";
    btn.style.alignItems = "center";
    btn.style.position = "relative";
    btn.style.cursor = "pointer";
    btn.style.userSelect = "none";

    const label = document.createElement("div");
    label.innerText = tool.name;
    label.style.fontSize = "18px";
    label.style.textShadow = "0 0 2px black";
    btn.appendChild(label);

    const num = document.createElement("div");
    num.innerText = (index + 1).toString();
    num.style.position = "absolute";
    num.style.bottom = "4px";
    num.style.left = "6px";
    num.style.fontSize = "16px";
    num.style.textShadow = "0 0 2px black";
    btn.appendChild(num);

    btn.onclick = () => {
      const ping = sounds.tool_ping;
      if (selectedToolIndex === index) {
        selectedToolIndex = -1;
        updateToolHighlight();
        if (ping && ping.loaded) try { ping.start(); } catch(e) {}
      } else {
        selectTool(index);
      }
    };

    toolBar.appendChild(btn);
    return btn;
  }

  window.toolDeclarations.forEach((tool, i) => {
    toolButtons.push(createToolButton(tool, i));
  });

  function updateToolHighlight() {
    toolButtons.forEach((btn, i) => {
      btn.style.outline = (i === selectedToolIndex)
        ? "3px solid yellow"
        : "none";
    });
  }

  function selectTool(i) {
    selectedToolIndex = i;
    updateToolHighlight();
    const ping = sounds.tool_ping;
    if (ping && ping.loaded) try { ping.start(); } catch(e) {}
  }

  updateToolHighlight();

  window.addEventListener("keydown", e => {
    const n = parseInt(e.key);
    if (!isNaN(n) && n >= 1 && n <= toolButtons.length) {
      const index = n - 1;
      const ping = sounds.tool_ping;

      if (selectedToolIndex === index) {
        selectedToolIndex = -1;
        updateToolHighlight();
        if (ping && ping.loaded) try { ping.start(); } catch(e) {}
      } else {
        selectTool(index);
      }
    }
  });

  function currentToolType() {
    if (selectedToolIndex === -1) return null;
    return window.toolDeclarations[selectedToolIndex].type;
  }

  function getMouseHit() {
    const pick = scene.pick(scene.pointerX, scene.pointerY);
    return pick && pick.hit ? pick : null;
  }

  const highlight = new BABYLON.HighlightLayer("hl", scene);

  function makeDraggable(mesh) {
    mesh.draggable = true;

    const bbox = mesh.getBoundingInfo().boundingBox.extendSize;
    const shape = new CANNON.Box(new CANNON.Vec3(bbox.x, bbox.y, bbox.z));

    const body = new CANNON.Body({
      mass: 1,
      material: groundMatPhys
    });

    body.addShape(shape);
    body.position.set(mesh.position.x, mesh.position.y, mesh.position.z);
    world.addBody(body);
    mesh.physicsBody = body;
  }

  makeDraggableRef = makeDraggable;

  function alignValue(v) {
  return Math.ceil(v);
}

function alignVector3(vec) {
  return new BABYLON.Vector3(
    alignValue(vec.x),
    alignValue(vec.y),
    alignValue(vec.z)
  );
}


  const projectiles = [];

  function getHeadForward() {
    const m = model.getWorldMatrix();
    const forward = BABYLON.Vector3.TransformNormal(
      new BABYLON.Vector3(0, 0, -1),
      m
    );
    forward.y = 0;
    return forward.normalize();
  }

  function spawnProjectile(opts) {
    const forward = getHeadForward();
    const fireDir = forward.scale(-1);

    const startPos = rig.position
      .add(new BABYLON.Vector3(0, 3, 0))
      .add(fireDir.scale(2));

    let mesh;
    if (opts.shape === "rocket") {
      mesh = BABYLON.MeshBuilder.CreateBox("rocket", {
        width: 1,
        height: 1,
        depth: 4
      }, scene);
      mesh.rotation.y = Math.atan2(fireDir.x, fireDir.z);
    } else {
      mesh = BABYLON.MeshBuilder.CreateSphere("proj", { diameter: opts.radius * 2 }, scene);
    }

    mesh.position.copyFrom(startPos);

    const mat = new BABYLON.StandardMaterial("projMat", scene);
    mat.diffuseColor = opts.color;
    mat.specularColor = new BABYLON.Color3(0,0,0);
    mesh.material = mat;

    const body = new CANNON.Body({
      mass: opts.usePhysics ? 1 : 0,
      material: groundMatPhys
    });

    if (opts.shape === "rocket") {
      body.addShape(new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 2)));
    } else {
      body.addShape(new CANNON.Sphere(opts.radius));
    }

    body.position.set(startPos.x, startPos.y, startPos.z);

    const vel = fireDir.scale(opts.speed);
    body.velocity.set(vel.x, vel.y, vel.z);

    world.addBody(body);

    projectiles.push({
      mesh,
      body,
      life: opts.life,
      isBomb: opts.isBomb,
      radius: opts.explosionRadius || 0,
      force: opts.explosionForce || 0,
      usePhysics: opts.usePhysics,
      speed: opts.speed
    });
  }

  function explodeAt(position, radius, force) {
    const playerDist = BABYLON.Vector3.Distance(
      new BABYLON.Vector3(playerBody.position.x, playerBody.position.y, playerBody.position.z),
      position
    );

    if (playerDist <= radius) {
      const ouch = sounds.ouch;
      if (ouch && ouch.loaded) try { ouch.start(); } catch(e) {}

      playerBody.position.set(spawnPoint.x, spawnPoint.y, spawnPoint.z);
      playerBody.velocity.set(0,0,0);

      rig.position.copyFrom(spawnPoint);
      model.rotation.y = 0;
      camYaw = Math.PI / 2;
    }

    scene.meshes.forEach(m => {
      if (!m.draggable) return;

      const diff = m.position.subtract(position);
      const dist = diff.length();
      if (dist > radius || dist === 0) return;

      if (!m.physicsBody) {
        const bbox = m.getBoundingInfo().boundingBox.extendSize;
        const shape = new CANNON.Box(new CANNON.Vec3(bbox.x, bbox.y, bbox.z));

        const body = new CANNON.Body({
          mass: 1,
          material: groundMatPhys
        });

        body.addShape(shape);
        body.position.set(m.position.x, m.position.y, m.position.z);
        world.addBody(body);
        m.physicsBody = body;
      }

      const dir = diff.normalize();
      const strength = (radius - dist) / radius * force;

      m.physicsBody.applyImpulse(
        new CANNON.Vec3(dir.x * strength, dir.y * strength, dir.z * strength),
        new CANNON.Vec3(0, 0, 0)
      );
    });

    const explosion = BABYLON.MeshBuilder.CreateSphere("explosion", { diameter: radius * 2 }, scene);
    const mat = new BABYLON.StandardMaterial("explosionMat", scene);
    mat.emissiveColor = new BABYLON.Color3(1, 0, 0);
    mat.diffuseColor  = new BABYLON.Color3(1, 0, 0);
    mat.alpha = 1.0;
    explosion.material = mat;
    explosion.position.copyFrom(position);

    const p = sounds.explosion;
    if (p && p.loaded) {
      try { p.start(); } catch(e) {}
    }

    setTimeout(() => explosion.dispose(), 300);
  }

  let draggedMesh = null;
  let dragOffset = null;

  ToolBehaviors.Grab = {
    pointerDown(pick) {
      if (!pick || !pick.pickedMesh || !pick.pickedMesh.draggable) return;
      draggedMesh = pick.pickedMesh;
      dragOffset = draggedMesh.position.subtract(pick.pickedPoint);
      highlight.addMesh(draggedMesh, BABYLON.Color3.Yellow());
    },
    pointerMove(pick) {
      if (!draggedMesh || !pick) return;
      const pos = pick.pickedPoint.add(dragOffset);
      draggedMesh.position.copyFrom(alignVector3(pos));

      if (draggedMesh.physicsBody) {
        draggedMesh.physicsBody.position.set(
          draggedMesh.position.x,
          draggedMesh.position.y,
          draggedMesh.position.z
        );
        draggedMesh.physicsBody.velocity.set(0,0,0);
      }
    },
    pointerUp() {
      if (draggedMesh) {
        highlight.removeMesh(draggedMesh);
        draggedMesh = null;
      }
    }
  };

  ToolBehaviors.Copy = {
    pointerDown(pick) {
      if (!pick || !pick.pickedMesh || !pick.pickedMesh.draggable) return;
      const ping = sounds.tool_ping;
      if (ping && ping.loaded) try { ping.start(); } catch(e) {}

      const original = pick.pickedMesh;
      const clone = original.clone(original.name + "_clone");
      clone.position.copyFrom(original.position);
      makeDraggable(clone);
      draggedMesh = clone;
      dragOffset = new BABYLON.Vector3(0,0,0);
      highlight.addMesh(draggedMesh, BABYLON.Color3.Yellow());
    },
    pointerMove(pick) {
      if (!draggedMesh || !pick) return;
      draggedMesh.position.copyFrom(alignVector3(pick.pickedPoint));

      if (draggedMesh.physicsBody) {
        draggedMesh.physicsBody.position.set(
          draggedMesh.position.x,
          draggedMesh.position.y,
          draggedMesh.position.z
        );
        draggedMesh.physicsBody.velocity.set(0,0,0);
      }
    },
    pointerUp() {
      if (draggedMesh) {
        highlight.removeMesh(draggedMesh);
        draggedMesh = null;
      }
    }
  };

  ToolBehaviors.Delete = {
    pointerDown(pick) {
      if (!pick || !pick.pickedMesh || !pick.pickedMesh.draggable) return;
      const snap = sounds.snap;
      if (snap && snap.loaded) try { snap.start(); } catch(e) {}

      highlight.removeMesh(pick.pickedMesh);

      if (pick.pickedMesh.physicsBody) {
        world.removeBody(pick.pickedMesh.physicsBody);
      }
      pick.pickedMesh.dispose();
    },
    pointerMove() {},
    pointerUp() {}
  };

  ToolBehaviors.SlingShot = {
    pointerDown() {
      const s = sounds.slingshot;
      if (s && s.loaded) try { s.start(); } catch(e) {}

      spawnProjectile({
        radius: 1,
        color: new BABYLON.Color3(0.7, 0.7, 0.7),
        life: 10,
        speed: 80,
        isBomb: false,
        explosionRadius: 0,
        explosionForce: 0,
        shape: "sphere",
        usePhysics: true
      });
    },
    pointerMove() {},
    pointerUp() {}
  };

  ToolBehaviors.Bomb = {
    pointerDown() {
      const ping = sounds.tool_ping;
      if (ping && ping.loaded) try { ping.start(); } catch(e) {}
      startBombTick();

      const pos = new BABYLON.Vector3(
        rig.position.x,
        rig.position.y + 1,
        rig.position.z
      );

      const mesh = BABYLON.MeshBuilder.CreateSphere("bomb", { diameter: 2 }, scene);
      const mat = new BABYLON.StandardMaterial("bombMat", scene);
      mat.diffuseColor = new BABYLON.Color3(0, 0, 0);
      mat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
      mesh.material = mat;
      mesh.position.copyFrom(pos);

      const body = new CANNON.Body({
        mass: 1,
        material: groundMatPhys
      });
      body.addShape(new CANNON.Sphere(1));
      body.position.set(pos.x, pos.y, pos.z);
      world.addBody(body);

      projectiles.push({
        mesh,
        body,
        life: 10,
        isBomb: true,
        radius: 10,
        force: 40,
        usePhysics: true,
        speed: 0
      });
    },
    pointerMove() {},
    pointerUp() {}
  };

  ToolBehaviors.RocketLauncher = {
    pointerDown() {
      const launch = sounds.rocket_launch;
      if (launch && launch.loaded) try { launch.start(); } catch(e) {}

      spawnProjectile({
        radius: 0.8,
        color: new BABYLON.Color3(0.2, 0.4, 1),
        life: 5,
        speed: 120,
        isBomb: true,
        explosionRadius: 12,
        explosionForce: 60,
        shape: "rocket",
        usePhysics: false
      });
    },
    pointerMove() {},
    pointerUp() {}
  };

  let toolPointerDown = false;

  canvas.addEventListener("pointerdown", (e) => {
    if (e.button !== 0) return;
    toolPointerDown = true;
    const pick = getMouseHit();
    const toolType = currentToolType();
    const behavior = ToolBehaviors[toolType];
    if (behavior && behavior.pointerDown) {
      behavior.pointerDown(pick);
    }
  });

  canvas.addEventListener("pointerup", (e) => {
    if (e.button !== 0) return;
    toolPointerDown = false;
    const toolType = currentToolType();
    const behavior = ToolBehaviors[toolType];
    if (behavior && behavior.pointerUp) {
      behavior.pointerUp();
    }
  });

  canvas.addEventListener("pointermove", () => {
    if (!toolPointerDown) return;
    const pick = getMouseHit();
    const toolType = currentToolType();
    const behavior = ToolBehaviors[toolType];
    if (behavior && behavior.pointerMove) {
      behavior.pointerMove(pick);
    }
  });

  scene.onBeforeRenderObservable.add(() => {
    const dt = engine.getDeltaTime() / 1000;
    const fixedTimeStep = 1 / 60;

    const forward = new BABYLON.Vector3(Math.sin(camYaw), 0, Math.cos(camYaw));
    const right = new BABYLON.Vector3(
      Math.sin(camYaw + Math.PI / 2),
      0,
      Math.cos(camYaw + Math.PI / 2)
    );

    let move = forward.scale(input.forward).add(right.scale(input.right));

    const isMoving = move.length() > 0.01;
    const onGround = playerBody.position.y <= rig.position.y + 0.2;

    const foot = sounds.footsteps;
    if (foot && foot.loaded) {
      if (!foot._started) {
        try { foot.start(); } catch(e) {}
        foot._started = true;
      }
      if (isMoving && onGround) {
        foot.volume.value = -5;
      } else {
        foot.volume.value = -60;
      }
    }

    if (isMoving) {
      move.normalize();
      rig.position.addInPlace(move.scale(walkSpeed));

      const targetAngle = Math.atan2(move.x, move.z);
      model.rotation.y = BABYLON.Scalar.Lerp(model.rotation.y, targetAngle, 0.15);
    }

    playerBody.position.x = rig.position.x;
    playerBody.position.z = rig.position.z;

    world.step(fixedTimeStep, dt, 3);

    rig.position.x = playerBody.position.x;
    rig.position.y = playerBody.position.y - capsuleHeight / 2 + 1;
    rig.position.z = playerBody.position.z;

    const headPos = new BABYLON.Vector3(
      rig.position.x,
      rig.position.y + 3.5,
      rig.position.z
    );

    const desiredCamPos = new BABYLON.Vector3(
      headPos.x + Math.sin(camYaw) * Math.cos(camPitch) * camDistance,
      headPos.y + Math.sin(camPitch) * camDistance,
      headPos.z + Math.cos(camYaw) * Math.cos(camPitch) * camDistance
    );

    camPos = BABYLON.Vector3.Lerp(camPos, desiredCamPos, dt / followTime);
    camera.position.copyFrom(camPos);

    camTarget = BABYLON.Vector3.Lerp(camTarget, headPos, dt / followTime);
    camera.setTarget(camTarget);

    for (let i = projectiles.length - 1; i >= 0; i--) {
      const p = projectiles[i];
      p.life -= dt;

      if (!p.usePhysics) {
        const dir = p.mesh.forward;
        p.body.position.x += dir.x * p.speed * dt;
        p.body.position.y += dir.y * p.speed * dt;
        p.body.position.z += dir.z * p.speed * dt;
      }

      p.mesh.position.set(p.body.position.x, p.body.position.y, p.body.position.z);

      scene.meshes.forEach(m => {
  if (!m.draggable) return;

  const dist = BABYLON.Vector3.Distance(m.position, p.mesh.position);

  // ðŸš€ Rockets explode on impact (speed > 0)
  if (dist < 2 && p.isBomb && p.speed > 0) {
    explodeAt(p.mesh.position.clone(), p.radius, p.force);
    world.removeBody(p.body);
    p.mesh.dispose();
    projectiles.splice(i, 1);
  }
});


      if (!projectiles[i]) continue;

      if (p.life <= 0) {
        if (p.isBomb) {
          stopBombTick();
          const r = p.radius || 10;
          const f = p.force || 40;
          explodeAt(p.mesh.position.clone(), r, f);
        }
        world.removeBody(p.body);
        p.mesh.dispose();
        projectiles.splice(i, 1);
      }
    }
  });

  return scene;
}

const scene = createScene();
engine.runRenderLoop(() => scene.render());
window.addEventListener("resize", () => engine.resize());
</script>

</body>
</html>
